import { ConnectButton } from "@rainbow-me/rainbowkit";
import type { NextPage } from "next";
import Head from "next/head";
import React, { useEffect, useState } from "react";
import {
  useAccount,
  useContract,
  useContractRead,
  useContractWrite,
  usePrepareContractWrite,
  useProvider,
} from "wagmi";
import deployment from "../abis/deployment.json";
import contractInterface from "../abis/NFTEnhancement.json";
import styles from "../styles/Home.module.css";

const filterContractConfig = {
  addressOrName: deployment.transactions[0].contractAddress,
  contractInterface: contractInterface.abi,
};

const Home: NextPage = () => {
  const { isConnected } = useAccount();

  return (
    <div className={styles.container}>
      <Head>
        <title>NFT Filters</title>
        <meta
          name="description"
          content="Generated by @rainbow-me/create-rainbowkit"
        />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1>NFT Filters</h1>
        <ConnectButton />

        <div className={styles.grid}>
          {isConnected ? <FilterFetcher /> : `Please connect to see a preview`}
        </div>
      </main>

      <footer className={styles.footer}>
        <a href="https://opensea.io/assets/ethereum/0xe41d8f993066db39a5bb3015d66a003792121757/">
          View on OpenSea üåä
        </a>
        <a
          href="https://github.com/MrToph/nft-enhancement"
          target="_blank"
          rel="noopener noreferrer"
        >
          Back to GitHub üë®‚Äçüíª
        </a>
      </footer>
    </div>
  );
};

const useFetchTokenIds = () => {
  const [tokenIds, setTokenIds] = useState([]);
  const provider = useProvider();
  const contract = useContract({
    addressOrName: filterContractConfig.addressOrName,
    contractInterface: contractInterface.abi,
    signerOrProvider: provider,
  });
  useEffect(() => {
    const fetchData = async () => {
      // list all events from 0 address, i.e., mints
      let mintFilter = contract.filters.Transfer(
        `0x0000000000000000000000000000000000000000`
      );
      let events = await contract.queryFilter(mintFilter);
      let ids = events.map((e: any) => e.args.id.toHexString());

      setTokenIds(ids);
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return tokenIds;
};

const FilterFetcher = () => {
  const tokenIds = useFetchTokenIds();

  if (tokenIds.length == 0) return <pre>Loading filters</pre>;
  return <RenderPreview tokenIds={tokenIds} />;
};

const RenderPreview: React.FC<{ tokenIds: string[] }> = ({ tokenIds }) => {
  const [selectValue, setSelectValue] = useState(tokenIds[0]);
  const [underlyingContractAddress, setUnderlyingContractAddress] = useState(
    `0xed5af388653567af2f388e6224dc7c4b3241c544` // Azuki
  );
  const [underlyingTokenId, setUnderlyingTokenId] = useState(`1234`);

  const { data: tokenURI } = useContractRead({
    ...filterContractConfig,
    functionName: "previewTokenURI",
    args: [selectValue, underlyingContractAddress, underlyingTokenId],
  });

  return (
    <section className={styles.render}>
      <div className={styles.row}>
        <label className={styles.label}>Filter</label>
        <select
          className={styles.input}
          onChange={(evt) => setSelectValue(evt.target.value)}
          value={selectValue}
        >
          {tokenIds.map((id) => (
            <option key={id}>{id}</option>
          ))}
        </select>
      </div>
      <div className={styles.row}>
        <label className={styles.label}>NFT contract</label>
        <input
          className={styles.input}
          onChange={(evt) => setUnderlyingContractAddress(evt.target.value)}
          placeholder="0xed5af388653567af2f388e6224dc7c4b3241c544"
          value={underlyingContractAddress}
        ></input>
      </div>
      <div className={styles.row}>
        <label className={styles.label}>NFT token ID</label>
        <input
          className={styles.input}
          onChange={(evt) => setUnderlyingTokenId(evt.target.value)}
          placeholder="1234"
          value={underlyingTokenId}
        ></input>
      </div>
      {tokenURI ? (
        <FilterImage tokenURI={tokenURI as unknown as string} />
      ) : null}
      <Submit
        tokenId={selectValue}
        underlyingContractAddress={underlyingContractAddress}
        underlyingTokenId={underlyingTokenId}
      />
    </section>
  );
};

const FilterImage: React.FC<{ tokenURI: string }> = ({ tokenURI }) => {
  let htmlBlob = ``;
  try {
    const metadata = JSON.parse(
      Buffer.from(
        tokenURI.replaceAll(`data:application/json;base64,`, ``),
        "base64"
      ).toString()
    );
    if (!metadata.animation_url)
      throw new Error(
        `No animation_url in metadata: ${JSON.stringify(metadata, null, 2)}`
      );
    // empty string means some internal call to the underlying failed in _getMetadata
    if (metadata.animation_url === `data:text/html;base64,`)
      throw new Error(
        `Underlying token contract & token ID not supported. Make sure it exists and is an ERC721 NFT with an "image" attribute.`
      );
    // starts `data:text/html;base64,` and can therefore directly be used as the source
    htmlBlob = metadata.animation_url;
  } catch (error: any) {
    console.error(`${tokenURI} - ${error.stack}`);
    return <div>{error.message}</div>;
  }

  // inline-styles & attributes from OpenSea
  return (
    <iframe
      allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
      frameBorder="0"
      height="100%"
      sandbox="allow-scripts"
      width="100%"
      style={{ minHeight: 500 }}
      src={htmlBlob}
    ></iframe>
  );
};

const Submit: React.FC<{
  tokenId: string;
  underlyingContractAddress: string;
  underlyingTokenId: string;
}> = ({ tokenId, underlyingContractAddress, underlyingTokenId }) => {
  const { config } = usePrepareContractWrite({
    ...filterContractConfig,
    functionName: "setUnderlyingToken",
    args: [tokenId, underlyingContractAddress, underlyingTokenId],
  });
  const { data, isLoading, isSuccess, write } = useContractWrite(config);

  // inline-styles & attributes from OpenSea
  return (
    <div className={styles.submit}>
      <button
        className={styles.submitButton}
        type="button"
        onClick={() => write?.()}
      >
        Set Underlying
      </button>
      {isLoading && <div className={styles.transaction}>Check Wallet</div>}
      {isSuccess && data && (
        <div className={styles.transaction}>Transaction: {data.hash}</div>
      )}
    </div>
  );
};

export default Home;
